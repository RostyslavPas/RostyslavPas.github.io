<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QA</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h2 {
            color: #2c3e50;
        }
        h3 {
            color: #34495e;
        }
        p {
            margin: 10px 0;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <h1>QA</h1>

    <h2>1. Аннотації</h2>
    <p>Аннотації — це метадані, які додаються до коду для опису поведінки, налаштування тестів або взаємодії з фреймворками. У тестуванні часто використовуються:</p>
    <ul>
        <li><code>@Test</code>: Позначає метод як тестовий.</li>
        <li><code>@BeforeMethod</code>: Виконує налаштування перед кожним тестом.</li>
        <li><code>@DataProvider</code>: Надає дані для параметризованих тестів.</li>
    </ul>
    <p><strong>Приклад:</strong></p>
    <code>
        @Test<br>
        public void testLogin() {<br>
        &nbsp;&nbsp;assertTrue(login("user", "password"));<br>
        }
    </code>

    <h2>2. Rest Assured</h2>
    <p>Rest Assured — це бібліотека для автоматизації тестування REST API. Вона дозволяє виконувати HTTP-запити (GET, POST, PUT, DELETE) і перевіряти відповіді.</p>
    <p><strong>REST Assured</strong> — це бібліотека Java для тестування RESTful API. Вона дозволяє легко створювати автоматизовані тести для API, використовуючи читабельний і зручний синтаксис, орієнтований на HTTP-запити та відповіді.</p>

    <h2>Особливості REST Assured:</h2>
    <ul>
        <li><strong>Простий синтаксис:</strong> Бібліотека надає DSL (Domain-Specific Language), який робить тестування API інтуїтивно зрозумілим.</li>
        <li><strong>JSON та XML підтримка:</strong> REST Assured дозволяє зручно працювати з JSON та XML, в тому числі перевіряти структуру та значення у відповіді.</li>
        <li><strong>Гнучкі твердження:</strong> Підтримує використання тверджень (assertions) для перевірки статус-кодів, заголовків, тіла відповіді тощо.</li>
        <li><strong>Інтеграція з тестовими фреймворками:</strong> Легко інтегрується з TestNG, JUnit та іншими бібліотеками.</li>
        <li><strong>Підтримка аутентифікації:</strong> REST Assured підтримує різні методи аутентифікації, включаючи Basic Auth, OAuth 2.0 тощо.</li>
    </ul>

    <h2>Приклад використання REST Assured:</h2>
    <p>Розглянемо простий приклад, де тестуємо GET-запит для отримання списку користувачів:</p>
    <pre><code>
import io.restassured.RestAssured;
import static io.restassured.RestAssured.*;
import static org.hamcrest.Matchers.*;

public class ApiTest {
    public void testGetUsers() {
        RestAssured.baseURI = "https://jsonplaceholder.typicode.com";

        given().
            log().all().
        when().
            get("/users").
        then().
            log().all().
            assertThat().
            statusCode(200).
            body("size()", greaterThan(0)).
            body("[0].email", notNullValue());
    }
}
    </code></pre>

    <h2>Ключові методи:</h2>
    <ul>
        <li><strong>given():</strong> Вказує попередні умови (наприклад, параметри, заголовки, тіло запиту).</li>
        <li><strong>when():</strong> Виконує HTTP-запит (GET, POST, PUT, DELETE).</li>
        <li><strong>then():</strong> Перевіряє (asserts) відповідь сервера (статус-коди, тіло, заголовки).</li>
    </ul>

    <h2>Підтримка аутентифікації:</h2>
    <p>REST Assured дозволяє використовувати різні типи аутентифікації, наприклад:</p>
    <ul>
        <li>Basic Authentication:</li>
        <pre><code>
given().
    auth().
    basic("username", "password").
when().
    get("/secure-endpoint").
then().
    statusCode(200);
        </code></pre>
        <li>Bearer Token:</li>
        <pre><code>
given().
    header("Authorization", "Bearer your_token_here").
when().
    get("/secure-endpoint").
then().
    statusCode(200);
        </code></pre>
    </ul>

    <h2>Чому варто використовувати REST Assured?</h2>
    <ul>
        <li><strong>Легкість використання:</strong> Зрозумілий API для роботи з HTTP-запитами та відповідями.</li>
        <li><strong>Інтеграція з CI/CD:</strong> REST Assured легко інтегрується у пайплайни Continuous Integration/Continuous Deployment.</li>
        <li><strong>Автоматизація:</strong> Ідеально підходить для написання регресійних та функціональних тестів API.</li>
    </ul>

    <h2>3. Selenide</h2>
    <p>Selenide — це фреймворк для автоматизації UI тестів на основі Selenium. Він забезпечує простий API, автоматичне очікування елементів і більше зручності при роботі з веб-додатками.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        $("input[name='username']").setValue("admin");<br>
        $("input[name='password']").setValue("password").pressEnter();<br>
        $("div.success").shouldHave(text("Welcome!"));
    </code>

    <h2>4. Паралеллізація</h2>
    <p>Паралеллізація дозволяє виконувати тести у кількох потоках для пришвидшення. Це досягається через налаштування конфігураційного файлу або параметрів фреймворку.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        &lt;suite name="ParallelTests" parallel="methods" thread-count="4"&gt;<br>
        &nbsp;&nbsp;&lt;test name="SampleTest"&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;classes&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;class name="com.example.MyTest" /&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/classes&gt;<br>
        &nbsp;&nbsp;&lt;/test&gt;<br>
        &lt;/suite&gt;
    </code>

    <h2>5. CI/CD</h2>
    <p>CI/CD — це набір практик для автоматизації інтеграції, тестування і деплою. CI забезпечує перевірку коду, а CD — автоматичну доставку продукту.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        stages:<br>
        - build<br>
        - test<br>
        - deploy<br><br>
        test:<br>
        &nbsp;&nbsp;stage: test<br>
        &nbsp;&nbsp;script:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;- pytest tests/
    </code>

    <h2>6. GitLab</h2>
    <p>GitLab — це платформа DevOps, яка включає систему контролю версій, CI/CD та інструменти для спільної роботи.</p>
    <p><strong>Приклад:</strong> Файл <code>.gitlab-ci.yml</code> для пайплайну:</p>
    <code>
        stages:<br>
        - build<br>
        - test<br>
        - deploy
    </code>

    <h2>7. Kubernetes (k8s)</h2>
    <p>Kubernetes — це платформа для управління контейнерами. Вона автоматизує масштабування, деплой і оновлення додатків.</p>
    <ol>
        <li><strong>Що таке Kubernetes?</strong>
            <p>Kubernetes — це open-source платформа для оркестрації контейнеризованих додатків. Вона дозволяє автоматизувати розгортання, управління та масштабування контейнерів.</p>
        </li>
        <li><strong>Контейнери та Docker</strong>
            <p>Kubernetes працює з контейнерами (зазвичай Docker), які ізолюють додатки та їх залежності, забезпечуючи консистентність середовищ незалежно від платформи.</p>
        </li>
        <li><strong>Архітектура Kubernetes:</strong>
            <ul>
                <li><strong>Кластер:</strong> основна структура, що складається з:
                    <ul>
                        <li><strong>Control Plane (План управління):</strong> керує всією інфраструктурою.</li>
                        <li><strong>Worker Nodes (Робочі вузли):</strong> виконують додатки у вигляді контейнерів.</li>
                    </ul>
                </li>
                <li><strong>ETCD:</strong> розподілена база даних, що зберігає стан кластера.</li>
                <li><strong>Kube-apiserver:</strong> головний компонент для API-запитів.</li>
                <li><strong>Kube-scheduler:</strong> визначає, на якому вузлі запускати додатки.</li>
                <li><strong>Kubelet:</strong> агент, який працює на кожному вузлі, забезпечуючи роботу контейнерів.</li>
            </ul>
        </li>
        <li><strong>Основні компоненти:</strong>
            <ul>
                <li><strong>Pods:</strong> Мінімальна одиниця розгортання в Kubernetes, яка може містити один або кілька контейнерів.</li>
                <li><strong>Services:</strong> Дають стабільну IP-адресу та DNS-ім’я для доступу до подів.</li>
                <li><strong>Namespaces:</strong> Використовуються для розділення ресурсів у кластері.</li>
                <li><strong>Deployments:</strong> Визначають, як і де повинні розгортатися поди.</li>
                <li><strong>ConfigMaps і Secrets:</strong> Дозволяють управляти конфігураціями та чутливими даними окремо від коду.</li>
            </ul>
        </li>
        <li><strong>Автоматизація:</strong>
            <p>Kubernetes автоматизує балансування навантаження, відновлення після збоїв, масштабування подів відповідно до навантаження та оновлення додатків без простоїв.</p>
        </li>
        <li><strong>Масштабованість:</strong>
            <p>Kubernetes дозволяє автоматично збільшувати або зменшувати кількість подів залежно від використання ресурсів (CPU, RAM) або інших метрик.</p>
        </li>
        <li><strong>Моніторинг і логування:</strong>
            <p>Kubernetes інтегрується з такими інструментами, як Prometheus, Grafana, Fluentd, для збору та відображення метрик і логів.</p>
        </li>
        <li><strong>Сумісність із хмарними провайдерами:</strong>
            <p>Kubernetes працює на різних хмарних платформах (AWS, Azure, GCP) та в локальних середовищах (on-premise).</p>
        </li>
        <li><strong>Інструменти для управління:</strong>
            <ul>
                <li><strong>Kubectl:</strong> CLI для роботи з кластерами Kubernetes.</li>
                <li><strong>Helm:</strong> Менеджер пакетів для управління складними додатками.</li>
                <li><strong>K9s:</strong> TUI-інструмент для спрощення управління кластером.</li>
            </ul>
        </li>
        <li><strong>Основні переваги:</strong>
            <ul>
                <li>Уніфіковане управління контейнеризованими додатками.</li>
                <li>Підтримка безперервної інтеграції та доставки (CI/CD).</li>
                <li>Економія ресурсів через автоматизацію.</li>
                <li>Стабільність і відмовостійкість.</li>
            </ul>
        </li>
        <li><strong>Чому Kubernetes називають "k8s"?</strong>
            <p>Скорочення "k8s" означає "Kubernetes", де "8" — це кількість літер між "k" і "s".</p>
        </li>
    </ol>

    <h2>8. Allure</h2>
    <p>Allure — це інструмент для створення наглядних репортів автоматизованих тестів. Він інтегрується з TestNG, JUnit, Pytest та іншими фреймворками.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        @Attachment(value = "Screenshot", type = "image/png")<br>
        public byte[] takeScreenshot() {<br>
        &nbsp;&nbsp;return ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);<br>
        }
    </code>

    <h2>9. Сліпи</h2>
    <p>Сліпи (<code>Thread.sleep()</code>) використовуються для очікування, але їх варто уникати через затримки у тестах.</p>
    <p><strong>Приклад:</strong> <code>Thread.sleep(2000);</code></p>

    <h2>10. Логи</h2>
    <p>Логи — це записи подій у системі, які допомагають відслідковувати роботу програми.</p>
    <p><strong>Приклад у Python:</strong></p>
    <code>
        import logging<br>
        logging.basicConfig(level=logging.INFO)<br>
        logging.info("Test started")
    </code>

    <h2>11. Ретраї</h2>
    <p>Ретраї — це повторний запуск тесту при невдачі.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        @Test(retryAnalyzer = RetryAnalyzer.class)
    </code>

    <h2>12. Техніки тест-дизайну</h2>
    <p>Це методи створення ефективних тест-кейсів, такі як:</p>
    <ul>
        <li>Еквівалентне розбиття.</li>
        <li>Аналіз граничних значень.</li>
        <li>Метод причин і наслідків.</li>
    </ul>

    <h2>13. Клієнт-серверна архітектура</h2>
    <p>Архітектура, де клієнт запитує дані, а сервер відповідає. Приклад: браузер надсилає запит до веб-сайту.</p>

    <h2>14. Що таке REST?</h2>
    <p><strong>REST</strong> (Representational State Transfer) — це архітектурний стиль для побудови веб-сервісів, який використовує HTTP для взаємодії між клієнтом і сервером. REST API забезпечує спосіб доступу до ресурсів через стандартні HTTP-методи (GET, POST, PUT, DELETE тощо).</p>

    <h2>Ключові принципи REST:</h2>
    <ul>
        <li><strong>Ресурси:</strong> Кожен ресурс ідентифікується унікальним URI (наприклад, <code>/users/1</code> для користувача з ID 1).</li>
        <li><strong>Стандартизовані методи:</strong> HTTP-методи (GET, POST, PUT, DELETE) відповідають CRUD-операціям (Create, Read, Update, Delete).</li>
        <li><strong>Безстанова взаємодія:</strong> Сервер не зберігає стану клієнта між запитами, кожен запит повинен містити всю необхідну інформацію.</li>
        <li><strong>Формати:</strong> Дані зазвичай передаються у форматі JSON або XML.</li>
    </ul>

    <h2>Відмінність між GET і POST:</h2>
    <ul>
        <li><strong>GET:</strong>
            <ul>
                <li>Призначений для отримання (читання) даних з сервера.</li>
                <li>Не змінює стан ресурсу.</li>
                <li>Дані передаються у URL (наприклад, <code>/api/v1/users?name=John</code>).</li>
                <li>Безпечний і ідемпотентний (повторні запити не змінюють результат).</li>
            </ul>
        </li>
        <li><strong>POST:</strong>
            <ul>
                <li>Призначений для створення нових ресурсів на сервері.</li>
                <li>Дані передаються у тілі запиту (body).</li>
                <li>Змінює стан сервера (додає нові записи).</li>
                <li>Не є ідемпотентним (повторний запит може створити кілька однакових ресурсів).</li>
            </ul>
        </li>
    </ul>

    <h2>Відмінність між PUT і PATCH:</h2>
    <ul>
        <li><strong>PUT:</strong>
            <ul>
                <li>Призначений для повного оновлення ресурсу.</li>
                <li>Вимагає передачі всіх полів ресурсу, навіть тих, які не змінюються.</li>
                <li>Ідемпотентний (повторний запит дає той самий результат).</li>
                <li>Наприклад, якщо ресурс <code>/users/1</code> виглядає так:
                    <pre>{"name": "John", "email": "john@example.com"}</pre>
                    і потрібно змінити ім'я, доведеться передати:
                    <pre>{"name": "John Doe", "email": "john@example.com"}</pre>
                </li>
            </ul>
        </li>
        <li><strong>PATCH:</strong>
            <ul>
                <li>Призначений для часткового оновлення ресурсу.</li>
                <li>Достатньо передати тільки ті поля, які змінюються.</li>
                <li>Не завжди ідемпотентний, залежить від реалізації.</li>
                <li>Наприклад, для зміни тільки імені ресурсу <code>/users/1</code> можна передати:
                    <pre>{"name": "John Doe"}</pre>
                </li>
            </ul>
        </li>
    </ul>

    <p>REST і SOAP — це протоколи для взаємодії між серверами та клієнтами.</p>
    <table>
        <thead>
            <tr>
                <th>Характеристика</th>
                <th>REST</th>
                <th>SOAP</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Протокол</td>
                <td>HTTP/HTTPS</td>
                <td>XML-based протокол</td>
            </tr>
            <tr>
                <td>Формат даних</td>
                <td>JSON, XML</td>
                <td>XML</td>
            </tr>
            <tr>
                <td>Легкість використання</td>
                <td>Простий і швидкий</td>
                <td>Складніший і більш структурований</td>
            </tr>
            <tr>
                <td>Підтримка операцій</td>
                <td>CRUD (Create, Read, Update, Delete)</td>
                <td>Підтримує складніші операції</td>
            </tr>
            <tr>
                <td>Швидкість</td>
                <td>Швидший, менше навантаження</td>
                <td>Повільніший через великий розмір повідомлень</td>
            </tr>
            <tr>
                <td>Безпека</td>
                <td>Використовує HTTPS, OAuth</td>
                <td>Вбудовані стандарти безпеки WS-Security</td>
            </tr>
        </tbody>
    </table>
</body>
</html>