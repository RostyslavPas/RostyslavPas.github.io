<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QA</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h2 {
            color: #2c3e50;
        }
        h3 {
            color: #34495e;
        }
        p {
            margin: 10px 0;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <h1>QA</h1>

    <h2>1. Аннотації</h2>
    <p>Аннотації — це метадані, які додаються до коду для опису поведінки, налаштування тестів або взаємодії з фреймворками. У тестуванні часто використовуються:</p>
    <ul>
        <li><code>@Test</code>: Позначає метод як тестовий.</li>
        <li><code>@BeforeMethod</code>: Виконує налаштування перед кожним тестом.</li>
        <li><code>@DataProvider</code>: Надає дані для параметризованих тестів.</li>
    </ul>
    <p><strong>Приклад:</strong></p>
    <code>
        @Test<br>
        public void testLogin() {<br>
        &nbsp;&nbsp;assertTrue(login("user", "password"));<br>
        }
    </code>

    <h2>2. Rest Assured</h2>
    <p>Rest Assured — це бібліотека для автоматизації тестування REST API. Вона дозволяє виконувати HTTP-запити (GET, POST, PUT, DELETE) і перевіряти відповіді.</p>
    <p><strong>REST Assured</strong> — це бібліотека Java для тестування RESTful API. Вона дозволяє легко створювати автоматизовані тести для API, використовуючи читабельний і зручний синтаксис, орієнтований на HTTP-запити та відповіді.</p>

    <h2>Особливості REST Assured:</h2>
    <ul>
        <li><strong>Простий синтаксис:</strong> Бібліотека надає DSL (Domain-Specific Language), який робить тестування API інтуїтивно зрозумілим.</li>
        <li><strong>JSON та XML підтримка:</strong> REST Assured дозволяє зручно працювати з JSON та XML, в тому числі перевіряти структуру та значення у відповіді.</li>
        <li><strong>Гнучкі твердження:</strong> Підтримує використання тверджень (assertions) для перевірки статус-кодів, заголовків, тіла відповіді тощо.</li>
        <li><strong>Інтеграція з тестовими фреймворками:</strong> Легко інтегрується з TestNG, JUnit та іншими бібліотеками.</li>
        <li><strong>Підтримка аутентифікації:</strong> REST Assured підтримує різні методи аутентифікації, включаючи Basic Auth, OAuth 2.0 тощо.</li>
    </ul>

    <h2>Приклад використання REST Assured:</h2>
    <p>Розглянемо простий приклад, де тестуємо GET-запит для отримання списку користувачів:</p>
    <pre><code>
import io.restassured.RestAssured;
import static io.restassured.RestAssured.*;
import static org.hamcrest.Matchers.*;

public class ApiTest {
    public void testGetUsers() {
        RestAssured.baseURI = "https://jsonplaceholder.typicode.com";

        given().
            log().all().
        when().
            get("/users").
        then().
            log().all().
            assertThat().
            statusCode(200).
            body("size()", greaterThan(0)).
            body("[0].email", notNullValue());
    }
}
    </code></pre>

    <h2>Ключові методи:</h2>
    <ul>
        <li><strong>given():</strong> Вказує попередні умови (наприклад, параметри, заголовки, тіло запиту).</li>
        <li><strong>when():</strong> Виконує HTTP-запит (GET, POST, PUT, DELETE).</li>
        <li><strong>then():</strong> Перевіряє (asserts) відповідь сервера (статус-коди, тіло, заголовки).</li>
    </ul>

    <h2>Підтримка аутентифікації:</h2>
    <p>REST Assured дозволяє використовувати різні типи аутентифікації, наприклад:</p>
    <ul>
        <li>Basic Authentication:</li>
        <pre><code>
given().
    auth().
    basic("username", "password").
when().
    get("/secure-endpoint").
then().
    statusCode(200);
        </code></pre>
        <li>Bearer Token:</li>
        <pre><code>
given().
    header("Authorization", "Bearer your_token_here").
when().
    get("/secure-endpoint").
then().
    statusCode(200);
        </code></pre>
    </ul>

    <h2>Чому варто використовувати REST Assured?</h2>
    <ul>
        <li><strong>Легкість використання:</strong> Зрозумілий API для роботи з HTTP-запитами та відповідями.</li>
        <li><strong>Інтеграція з CI/CD:</strong> REST Assured легко інтегрується у пайплайни Continuous Integration/Continuous Deployment.</li>
        <li><strong>Автоматизація:</strong> Ідеально підходить для написання регресійних та функціональних тестів API.</li>
    </ul>

    <h2>3. Selenide</h2>
    <p>Selenide — це фреймворк для автоматизації UI тестів на основі Selenium. Він забезпечує простий API, автоматичне очікування елементів і більше зручності при роботі з веб-додатками.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        $("input[name='username']").setValue("admin");<br>
        $("input[name='password']").setValue("password").pressEnter();<br>
        $("div.success").shouldHave(text("Welcome!"));
    </code>

    <h2>4. Паралеллізація</h2>
    <p>Паралеллізація дозволяє виконувати тести у кількох потоках для пришвидшення. Це досягається через налаштування конфігураційного файлу або параметрів фреймворку.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        &lt;suite name="ParallelTests" parallel="methods" thread-count="4"&gt;<br>
        &nbsp;&nbsp;&lt;test name="SampleTest"&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;classes&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;class name="com.example.MyTest" /&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/classes&gt;<br>
        &nbsp;&nbsp;&lt;/test&gt;<br>
        &lt;/suite&gt;
    </code>

    <h2>5. CI/CD</h2>
    <p>CI/CD — це набір практик для автоматизації інтеграції, тестування і деплою. CI забезпечує перевірку коду, а CD — автоматичну доставку продукту.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        stages:<br>
        - build<br>
        - test<br>
        - deploy<br><br>
        test:<br>
        &nbsp;&nbsp;stage: test<br>
        &nbsp;&nbsp;script:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;- pytest tests/
    </code>

    <h2>6. GitLab</h2>
    <p>GitLab — це платформа DevOps, яка включає систему контролю версій, CI/CD та інструменти для спільної роботи.</p>
    <p><strong>Приклад:</strong> Файл <code>.gitlab-ci.yml</code> для пайплайну:</p>
    <code>
        stages:<br>
        - build<br>
        - test<br>
        - deploy
    </code>

    <h2>7. Kubernetes (k8s)</h2>
    <p>Kubernetes — це платформа для управління контейнерами. Вона автоматизує масштабування, деплой і оновлення додатків.</p>
    <ol>
        <li><strong>Що таке Kubernetes?</strong>
            <p>Kubernetes — це open-source платформа для оркестрації контейнеризованих додатків. Вона дозволяє автоматизувати розгортання, управління та масштабування контейнерів.</p>
        </li>
        <li><strong>Контейнери та Docker</strong>
            <p>Kubernetes працює з контейнерами (зазвичай Docker), які ізолюють додатки та їх залежності, забезпечуючи консистентність середовищ незалежно від платформи.</p>
        </li>
        <li><strong>Архітектура Kubernetes:</strong>
            <ul>
                <li><strong>Кластер:</strong> основна структура, що складається з:
                    <ul>
                        <li><strong>Control Plane (План управління):</strong> керує всією інфраструктурою.</li>
                        <li><strong>Worker Nodes (Робочі вузли):</strong> виконують додатки у вигляді контейнерів.</li>
                    </ul>
                </li>
                <li><strong>ETCD:</strong> розподілена база даних, що зберігає стан кластера.</li>
                <li><strong>Kube-apiserver:</strong> головний компонент для API-запитів.</li>
                <li><strong>Kube-scheduler:</strong> визначає, на якому вузлі запускати додатки.</li>
                <li><strong>Kubelet:</strong> агент, який працює на кожному вузлі, забезпечуючи роботу контейнерів.</li>
            </ul>
        </li>
        <li><strong>Основні компоненти:</strong>
            <ul>
                <li><strong>Pods:</strong> Мінімальна одиниця розгортання в Kubernetes, яка може містити один або кілька контейнерів.</li>
                <li><strong>Services:</strong> Дають стабільну IP-адресу та DNS-ім’я для доступу до подів.</li>
                <li><strong>Namespaces:</strong> Використовуються для розділення ресурсів у кластері.</li>
                <li><strong>Deployments:</strong> Визначають, як і де повинні розгортатися поди.</li>
                <li><strong>ConfigMaps і Secrets:</strong> Дозволяють управляти конфігураціями та чутливими даними окремо від коду.</li>
            </ul>
        </li>
        <li><strong>Автоматизація:</strong>
            <p>Kubernetes автоматизує балансування навантаження, відновлення після збоїв, масштабування подів відповідно до навантаження та оновлення додатків без простоїв.</p>
        </li>
        <li><strong>Масштабованість:</strong>
            <p>Kubernetes дозволяє автоматично збільшувати або зменшувати кількість подів залежно від використання ресурсів (CPU, RAM) або інших метрик.</p>
        </li>
        <li><strong>Моніторинг і логування:</strong>
            <p>Kubernetes інтегрується з такими інструментами, як Prometheus, Grafana, Fluentd, для збору та відображення метрик і логів.</p>
        </li>
        <li><strong>Сумісність із хмарними провайдерами:</strong>
            <p>Kubernetes працює на різних хмарних платформах (AWS, Azure, GCP) та в локальних середовищах (on-premise).</p>
        </li>
        <li><strong>Інструменти для управління:</strong>
            <ul>
                <li><strong>Kubectl:</strong> CLI для роботи з кластерами Kubernetes.</li>
                <li><strong>Helm:</strong> Менеджер пакетів для управління складними додатками.</li>
                <li><strong>K9s:</strong> TUI-інструмент для спрощення управління кластером.</li>
            </ul>
        </li>
        <li><strong>Основні переваги:</strong>
            <ul>
                <li>Уніфіковане управління контейнеризованими додатками.</li>
                <li>Підтримка безперервної інтеграції та доставки (CI/CD).</li>
                <li>Економія ресурсів через автоматизацію.</li>
                <li>Стабільність і відмовостійкість.</li>
            </ul>
        </li>
        <li><strong>Чому Kubernetes називають "k8s"?</strong>
            <p>Скорочення "k8s" означає "Kubernetes", де "8" — це кількість літер між "k" і "s".</p>
        </li>
    </ol>

    <h2>8. Allure</h2>
    <p>Allure — це інструмент для створення наглядних репортів автоматизованих тестів. Він інтегрується з TestNG, JUnit, Pytest та іншими фреймворками.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        @Attachment(value = "Screenshot", type = "image/png")<br>
        public byte[] takeScreenshot() {<br>
        &nbsp;&nbsp;return ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);<br>
        }
    </code>

    <h2>9. Сліпи</h2>
    <p>Сліпи (<code>Thread.sleep()</code>) використовуються для очікування, але їх варто уникати через затримки у тестах.</p>
    <p><strong>Приклад:</strong> <code>Thread.sleep(2000);</code></p>

    <h2>10. Логи</h2>
    <p>Логи — це записи подій у системі, які допомагають відслідковувати роботу програми.</p>
    <p><strong>Приклад у Python:</strong></p>
    <code>
        import logging<br>
        logging.basicConfig(level=logging.INFO)<br>
        logging.info("Test started")
    </code>

    <h2>11. Ретраї</h2>
    <p>Ретраї — це повторний запуск тесту при невдачі.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        @Test(retryAnalyzer = RetryAnalyzer.class)
    </code>

    <h2>12. Техніки тест-дизайну</h2>
    <p>Це методи створення ефективних тест-кейсів, такі як:</p>
    <ul>
        <li>Еквівалентне розбиття.</li>
        <li>Аналіз граничних значень.</li>
        <li>Метод причин і наслідків.</li>
    </ul>

    <h2>14. Що таке REST?</h2>
    <p><strong>REST</strong> (Representational State Transfer) — це архітектурний стиль для побудови веб-сервісів, який використовує HTTP для взаємодії між клієнтом і сервером. REST API забезпечує спосіб доступу до ресурсів через стандартні HTTP-методи (GET, POST, PUT, DELETE тощо).</p>

    <h2>Ключові принципи REST:</h2>
    <ul>
        <li><strong>Ресурси:</strong> Кожен ресурс ідентифікується унікальним URI (наприклад, <code>/users/1</code> для користувача з ID 1).</li>
        <li><strong>Стандартизовані методи:</strong> HTTP-методи (GET, POST, PUT, DELETE) відповідають CRUD-операціям (Create, Read, Update, Delete).</li>
        <li><strong>Безстанова взаємодія:</strong> Сервер не зберігає стану клієнта між запитами, кожен запит повинен містити всю необхідну інформацію.</li>
        <li><strong>Формати:</strong> Дані зазвичай передаються у форматі JSON або XML.</li>
    </ul>

    <h2>Відмінність між GET і POST:</h2>
    <ul>
        <li><strong>GET:</strong>
            <ul>
                <li>Призначений для отримання (читання) даних з сервера.</li>
                <li>Не змінює стан ресурсу.</li>
                <li>Дані передаються у URL (наприклад, <code>/api/v1/users?name=John</code>).</li>
                <li>Безпечний і ідемпотентний (повторні запити не змінюють результат).</li>
            </ul>
        </li>
        <li><strong>POST:</strong>
            <ul>
                <li>Призначений для створення нових ресурсів на сервері.</li>
                <li>Дані передаються у тілі запиту (body).</li>
                <li>Змінює стан сервера (додає нові записи).</li>
                <li>Не є ідемпотентним (повторний запит може створити кілька однакових ресурсів).</li>
            </ul>
        </li>
    </ul>

    <h2>Відмінність між PUT і PATCH:</h2>
    <ul>
        <li><strong>PUT:</strong>
            <ul>
                <li>Призначений для повного оновлення ресурсу.</li>
                <li>Вимагає передачі всіх полів ресурсу, навіть тих, які не змінюються.</li>
                <li>Ідемпотентний (повторний запит дає той самий результат).</li>
                <li>Наприклад, якщо ресурс <code>/users/1</code> виглядає так:
                    <pre>{"name": "John", "email": "john@example.com"}</pre>
                    і потрібно змінити ім'я, доведеться передати:
                    <pre>{"name": "John Doe", "email": "john@example.com"}</pre>
                </li>
            </ul>
        </li>
        <li><strong>PATCH:</strong>
            <ul>
                <li>Призначений для часткового оновлення ресурсу.</li>
                <li>Достатньо передати тільки ті поля, які змінюються.</li>
                <li>Не завжди ідемпотентний, залежить від реалізації.</li>
                <li>Наприклад, для зміни тільки імені ресурсу <code>/users/1</code> можна передати:
                    <pre>{"name": "John Doe"}</pre>
                </li>
            </ul>
        </li>
    </ul>

    <p>REST і SOAP — це протоколи для взаємодії між серверами та клієнтами.</p>
    <table>
        <thead>
            <tr>
                <th>Характеристика</th>
                <th>REST</th>
                <th>SOAP</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Протокол</td>
                <td>HTTP/HTTPS</td>
                <td>XML-based протокол</td>
            </tr>
            <tr>
                <td>Формат даних</td>
                <td>JSON, XML</td>
                <td>XML</td>
            </tr>
            <tr>
                <td>Легкість використання</td>
                <td>Простий і швидкий</td>
                <td>Складніший і більш структурований</td>
            </tr>
            <tr>
                <td>Підтримка операцій</td>
                <td>CRUD (Create, Read, Update, Delete)</td>
                <td>Підтримує складніші операції</td>
            </tr>
            <tr>
                <td>Швидкість</td>
                <td>Швидший, менше навантаження</td>
                <td>Повільніший через великий розмір повідомлень</td>
            </tr>
            <tr>
                <td>Безпека</td>
                <td>Використовує HTTPS, OAuth</td>
                <td>Вбудовані стандарти безпеки WS-Security</td>
            </tr>
        </tbody>
    </table>
    <h2>15. Інтерфейс та Абстрактний клас</h2>

    <h2>Що таке інтерфейс?</h2>
    <p><strong>Інтерфейс</strong> — це контракт, який визначає набір методів, які клас, що реалізує цей інтерфейс, зобов'язаний реалізувати.</p>
    <ul>
        <li>В інтерфейсі <strong>немає реалізації методів</strong> (за винятком можливих дефолтних методів у Java).</li>
        <li>Інтерфейси використовуються для забезпечення багатоспадковості.</li>
        <li>Інтерфейс лише визначає <strong>що потрібно робити</strong>, а не <strong>як це потрібно робити</strong>.</li>
    </ul>

    <h3>Приклад інтерфейсу</h3>
    <code>
public interface Animal {<br>
    void eat();<br>
    void sleep();<br>
}<br><br>
public class Dog implements Animal {<br>
    @Override<br>
    public void eat() {<br>
        System.out.println("Dog eats.");<br>
    }<br><br>
    @Override<br>
    public void sleep() {<br>
        System.out.println("Dog sleeps.");<br>
    }<br>
}
    </code>

    <h2>Що таке абстрактний клас?</h2>
    <p><strong>Абстрактний клас</strong> — це клас, який не можна створити як об'єкт і який може містити як абстрактні методи (без реалізації), так і методи з реалізацією.</p>
    <ul>
        <li>Абстрактний клас використовується для задання базової поведінки, яку дочірні класи можуть розширити або перевизначити.</li>
        <li>Може містити <strong>реалізовані та нереалізовані методи</strong>.</li>
        <li>Підтримує конструкції, властиві звичайним класам (наприклад, конструктори).</li>
    </ul>

    <h3>Приклад абстрактного класу</h3>
    <code>
public abstract class Animal {<br>
    abstract void eat(); // Абстрактний метод<br><br>
    void sleep() { // Метод з реалізацією<br>
        System.out.println("Animal sleeps.");<br>
    }<br>
}<br><br>
public class Dog extends Animal {<br>
    @Override<br>
    void eat() {<br>
        System.out.println("Dog eats.");<br>
    }<br>
}
    </code>

    <h2>Відмінності між інтерфейсом та абстрактним класом</h2>
    <table>
        <thead>
            <tr>
                <th>Критерій</th>
                <th>Інтерфейс</th>
                <th>Абстрактний клас</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Мета</td>
                <td>Описує контракт (що повинно бути зроблено).</td>
                <td>Служить базовим класом із можливістю часткової реалізації.</td>
            </tr>
            <tr>
                <td>Реалізація методів</td>
                <td>Методи без реалізації (до Java 8). Може мати <code>default</code> методи (з Java 8).</td>
                <td>Може містити як реалізовані, так і абстрактні методи.</td>
            </tr>
            <tr>
                <td>Множинне успадкування</td>
                <td>Клас може реалізовувати кілька інтерфейсів.</td>
                <td>Клас може успадковувати лише один абстрактний клас.</td>
            </tr>
            <tr>
                <td>Поле</td>
                <td>Тільки <code>static</code> і <code>final</code> (константи).</td>
                <td>Може містити будь-які змінні.</td>
            </tr>
            <tr>
                <td>Конструктори</td>
                <td>Не може мати конструкторів.</td>
                <td>Може мати конструктори.</td>
            </tr>
            <tr>
                <td>Де використовується</td>
                <td>Коли потрібна багатоспадковість та спільний контракт для різних класів.</td>
                <td>Коли потрібна базова реалізація для групи пов'язаних класів.</td>
            </tr>
        </tbody>
    </table>

    <h2>Коли використовувати?</h2>
    <ul>
        <li>Використовуйте <strong>інтерфейс</strong>, якщо хочете задати лише контракт для реалізації.</li>
        <li>Використовуйте <strong>абстрактний клас</strong>, якщо хочете забезпечити базову реалізацію, яку можуть розширювати дочірні класи.</li>
    </ul>
    <h2>Типи даних у Java</h2>
    <p>У Java підтримуються два види типів даних: примітивні та посилальні. Нижче наведено деталі:</p>

    <h3>Примітивні типи даних</h3>
    <table>
        <thead>
            <tr>
                <th>Тип</th>
                <th>Розмір</th>
                <th>Значення за замовчуванням</th>
                <th>Приклад</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>byte</td>
                <td>8 біт</td>
                <td>0</td>
                <td><code>byte b = 100;</code></td>
            </tr>
            <tr>
                <td>short</td>
                <td>16 біт</td>
                <td>0</td>
                <td><code>short s = 30000;</code></td>
            </tr>
            <tr>
                <td>int</td>
                <td>32 біт</td>
                <td>0</td>
                <td><code>int i = 100000;</code></td>
            </tr>
            <tr>
                <td>long</td>
                <td>64 біт</td>
                <td>0L</td>
                <td><code>long l = 100000L;</code></td>
            </tr>
            <tr>
                <td>float</td>
                <td>32 біт</td>
                <td>0.0f</td>
                <td><code>float f = 10.5f;</code></td>
            </tr>
            <tr>
                <td>double</td>
                <td>64 біт</td>
                <td>0.0d</td>
                <td><code>double d = 20.5;</code></td>
            </tr>
            <tr>
                <td>char</td>
                <td>16 біт</td>
                <td>'\u0000'</td>
                <td><code>char c = 'A';</code></td>
            </tr>
            <tr>
                <td>boolean</td>
                <td>1 біт</td>
                <td>false</td>
                <td><code>boolean b = true;</code></td>
            </tr>
        </tbody>
    </table>

    <h2>Операції в Java</h2>
    <p>Java підтримує кілька груп операцій, які дозволяють маніпулювати змінними, значеннями та об'єктами.</p>

    <h3>Групи операцій</h3>
    <table>
        <thead>
            <tr>
                <th>Група</th>
                <th>Опис</th>
                <th>Приклади</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Арифметичні</td>
                <td>Операції для математичних обчислень</td>
                <td><code>+, -, *, /, %</code></td>
            </tr>
            <tr>
                <td>Операції порівняння</td>
                <td>Порівнюють два значення</td>
                <td><code>==, !=, >, <, >=, <=</code></td>
            </tr>
            <tr>
                <td>Логічні</td>
                <td>Операції для логічних умов</td>
                <td><code>&&, ||, !</code></td>
            </tr>
            <tr>
                <td>Бітові</td>
                <td>Робота з бітами</td>
                <td><code>&, |, ^, ~, <<, >>, >>></code></td>
            </tr>
            <tr>
                <td>Операції присвоєння</td>
                <td>Присвоєння значень змінним</td>
                <td><code>=, +=, -=, *=, /=, %=</code></td>
            </tr>
            <tr>
                <td>Інкремент/Декремент</td>
                <td>Збільшення або зменшення значення на одиницю</td>
                <td><code>++, --</code></td>
            </tr>
            <tr>
                <td>Тернарна операція</td>
                <td>Скорочена форма умови <code>if-else</code></td>
                <td><code>condition ? value1 : value2</code></td>
            </tr>
            <tr>
                <td>Операції з об'єктами</td>
                <td>Перевірка та приведення типів</td>
                <td><code>instanceof, new, (Type)</code></td>
            </tr>
        </tbody>
    </table>
    <h2>Shift-Left Testing</h2>
    <p>Shift-Left Testing — це підхід, що передбачає переміщення процесів тестування на ранні етапи життєвого циклу розробки програмного забезпечення (SDLC).</p>
    <ul>
        <li><b>Ціль</b>: знайти дефекти на ранніх етапах, зменшити витрати на виправлення та покращити якість.</li>
        <li><b>Реалізація</b>: використання автоматизованих тестів (unit, integration), участь тестувальників у стадії проєктування.</li>
        <li><b>Переваги</b>: швидше виявлення помилок, зменшення ризиків, ефективність.</li>
    </ul>

    <h2>Веб-сокети</h2>
    <p>Веб-сокети — це протокол зв’язку, що забезпечує дуплексний (двосторонній) зв’язок між клієнтом і сервером через один TCP-з’єднання.</p>
    <ul>
        <li><b>Використання</b>: чати, онлайн-ігри, біржі.</li>
        <li><b>Як працюють</b>:
            <ul>
                <li>Встановлюється з’єднання через HTTP-запит.</li>
                <li>Сервер та клієнт переходять до WebSocket-протоколу.</li>
                <li>Обмін даними в реальному часі без переривання.</li>
            </ul>
        </li>
    </ul>

    <h2>Клієнт-серверна архітектура</h2>
    <p>Клієнт-серверна архітектура передбачає взаємодію між клієнтом і сервером через мережу.</p>
    <ul>
        <li><b>Клієнт</b>: відправляє запити (браузери, мобільні додатки).</li>
        <li><b>Сервер</b>: обробляє запити, виконує бізнес-логіку, повертає відповіді.</li>
        <li><b>Кеш</b>: зменшує навантаження на сервер, прискорює відповідь.</li>
        <li><b>Протоколи</b>:
            <ul>
                <li>HTTP (незахищений).</li>
                <li>HTTPS (захищений шифруванням TLS).</li>
            </ul>
        </li>
        <li><b>Шифрування HTTPS</b>: забезпечує безпеку даних через сертифікати SSL/TLS.</li>
    </ul>

    <h2>REST-запити</h2>
    <p>REST (Representational State Transfer) — архітектурний стиль, що використовує HTTP для зв’язку клієнта з сервером.</p>
    <h3>Різниця між POST і PUT:</h3>
    <ul>
        <li><b>POST</b>: створення нового ресурсу.
            <ul>
                <li>Приклад: POST /users додає нового користувача.</li>
            </ul>
        </li>
        <li><b>PUT</b>: створення або оновлення ресурсу.
            <ul>
                <li>Приклад: PUT /users/1 оновлює існуючого користувача (ID = 1).</li>
            </ul>
        </li>
    </ul>
    <h3>Query-параметри:</h3>
    <ul>
        <li>Використовуються для передачі фільтрів або умов.</li>
        <li>Приклад: GET /products?category=books&price=100.</li>
    </ul>

    <h2>Принципи тестування</h2>
    <ul>
        <li>Тестування демонструє наявність дефектів.</li>
        <li>Вичерпне тестування неможливе.</li>
        <li>Раннє тестування заощаджує ресурси.</li>
        <li>Помилки групуються (принцип Парето: 20% коду викликають 80% дефектів).</li>
        <li>Парадокс помилок (одна і та ж помилка не повинна знаходитися більше одного разу).</li>
        <li>Контекстне тестування.</li>
        <li>Відсутність помилок не гарантує придатності системи.</li>
    </ul>

    <h3>Maven:</h3>
    <ul>
        <li><b>Навіщо Maven</b>:
            <ul>
                <li>Управління залежностями (Selenium, RestAssured).</li>
                <li>Збірка та запуск тестів.</li>
                <li>Інтеграція з CI/CD.</li>
            </ul>
        </li>
    </ul>

    <h3>Merge-конфлікти:</h3>
    <ul>
        <li><b>Причини</b>:
            <ul>
                <li>Зміна одного файлу різними розробниками.</li>
                <li>Некоректний порядок виконання merge/pull.</li>
            </ul>
        </li>
        <li><b>Рішення</b>:
            <ul>
                <li>Розв’язання конфліктів у ручному режимі.</li>
                <li>Уніфікація коду за допомогою code review.</li>
            </ul>
        </li>
    </ul>

</body>
</html>