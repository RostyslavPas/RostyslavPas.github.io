<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QA</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h2 {
            color: #2c3e50;
        }
        h3 {
            color: #34495e;
        }
        p {
            margin: 10px 0;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <h1>QA</h1>

    <h2>1. Аннотації</h2>
    <p>Аннотації — це метадані, які додаються до коду для опису поведінки, налаштування тестів або взаємодії з фреймворками. У тестуванні часто використовуються:</p>
    <ul>
        <li><code>@Test</code>: Позначає метод як тестовий.</li>
        <li><code>@BeforeMethod</code>: Виконує налаштування перед кожним тестом.</li>
        <li><code>@DataProvider</code>: Надає дані для параметризованих тестів.</li>
    </ul>
    <p><strong>Приклад:</strong></p>
    <code>
        @Test<br>
        public void testLogin() {<br>
        &nbsp;&nbsp;assertTrue(login("user", "password"));<br>
        }
    </code>

    <h2>2. Rest Assured</h2>
    <p>Rest Assured — це бібліотека для автоматизації тестування REST API. Вона дозволяє виконувати HTTP-запити (GET, POST, PUT, DELETE) і перевіряти відповіді.</p>
    <p><strong>REST Assured</strong> — це бібліотека Java для тестування RESTful API. Вона дозволяє легко створювати автоматизовані тести для API, використовуючи читабельний і зручний синтаксис, орієнтований на HTTP-запити та відповіді.</p>

    <h2>Особливості REST Assured:</h2>
    <ul>
        <li><strong>Простий синтаксис:</strong> Бібліотека надає DSL (Domain-Specific Language), який робить тестування API інтуїтивно зрозумілим.</li>
        <li><strong>JSON та XML підтримка:</strong> REST Assured дозволяє зручно працювати з JSON та XML, в тому числі перевіряти структуру та значення у відповіді.</li>
        <li><strong>Гнучкі твердження:</strong> Підтримує використання тверджень (assertions) для перевірки статус-кодів, заголовків, тіла відповіді тощо.</li>
        <li><strong>Інтеграція з тестовими фреймворками:</strong> Легко інтегрується з TestNG, JUnit та іншими бібліотеками.</li>
        <li><strong>Підтримка аутентифікації:</strong> REST Assured підтримує різні методи аутентифікації, включаючи Basic Auth, OAuth 2.0 тощо.</li>
    </ul>
    <h2>Ключові методи:</h2>
    <ul>
        <li><strong>given():</strong> Вказує попередні умови (наприклад, параметри, заголовки, тіло запиту).</li>
        <li><strong>when():</strong> Виконує HTTP-запит (GET, POST, PUT, DELETE).</li>
        <li><strong>then():</strong> Перевіряє (asserts) відповідь сервера (статус-коди, тіло, заголовки).</li>
    </ul>

    <h2>Чому варто використовувати REST Assured?</h2>
    <ul>
        <li><strong>Легкість використання:</strong> Зрозумілий API для роботи з HTTP-запитами та відповідями.</li>
        <li><strong>Інтеграція з CI/CD:</strong> REST Assured легко інтегрується у пайплайни Continuous Integration/Continuous Deployment.</li>
        <li><strong>Автоматизація:</strong> Ідеально підходить для написання регресійних та функціональних тестів API.</li>
    </ul>

    <h2>3. Selenide</h2>
    <p>Selenide — це фреймворк для автоматизації UI тестів на основі Selenium. Він забезпечує простий API, автоматичне очікування елементів і більше зручності при роботі з веб-додатками.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        $("input[name='username']").setValue("admin");<br>
        $("input[name='password']").setValue("password").pressEnter();<br>
        $("div.success").shouldHave(text("Welcome!"));
    </code>

    <h2>4. Паралеллізація</h2>
    <p>Паралеллізація дозволяє виконувати тести у кількох потоках для пришвидшення. Це досягається через налаштування конфігураційного файлу або параметрів фреймворку.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        &lt;suite name="ParallelTests" parallel="methods" thread-count="4"&gt;<br>
        &nbsp;&nbsp;&lt;test name="SampleTest"&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;classes&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;class name="com.example.MyTest" /&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/classes&gt;<br>
        &nbsp;&nbsp;&lt;/test&gt;<br>
        &lt;/suite&gt;
    </code>

    <h2>5. CI/CD</h2>
    <p>CI/CD — це набір практик для автоматизації інтеграції, тестування і деплою. CI забезпечує перевірку коду, а CD — автоматичну доставку продукту.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        stages:<br>
        - build<br>
        - test<br>
        - deploy<br><br>
        test:<br>
        &nbsp;&nbsp;stage: test<br>
        &nbsp;&nbsp;script:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;- pytest tests/
    </code>

    <h2>6. GitLab</h2>
    <p>GitLab — це платформа DevOps, яка включає систему контролю версій, CI/CD та інструменти для спільної роботи.</p>
    <p><strong>Приклад:</strong> Файл <code>.gitlab-ci.yml</code> для пайплайну:</p>
    <code>
        stages:<br>
        - build<br>
        - test<br>
        - deploy
    </code>

    <h2>7. Kubernetes (k8s)</h2>
    <p>Kubernetes — це платформа для управління контейнерами. Вона автоматизує масштабування, деплой і оновлення додатків.</p>
    <ol>
        <li><strong>Контейнери та Docker</strong>
            <p>Kubernetes працює з контейнерами (зазвичай Docker), які ізолюють додатки та їх залежності, забезпечуючи консистентність середовищ незалежно від платформи.</p>
        </li>
        <li><strong>Основні компоненти:</strong>
            <ul>
                <li><strong>Pods:</strong> Мінімальна одиниця розгортання в Kubernetes, яка може містити один або кілька контейнерів.</li>
                <li><strong>Services:</strong> Дають стабільну IP-адресу та DNS-ім’я для доступу до подів.</li>
                <li><strong>Namespaces:</strong> Використовуються для розділення ресурсів у кластері.</li>
                <li><strong>Deployments:</strong> Визначають, як і де повинні розгортатися поди.</li>
                <li><strong>ConfigMaps і Secrets:</strong> Дозволяють управляти конфігураціями та чутливими даними окремо від коду.</li>
            </ul>
        </li>
        <li><strong>Чому Kubernetes називають "k8s"?</strong>
            <p>Скорочення "k8s" означає "Kubernetes", де "8" — це кількість літер між "k" і "s".</p>
        </li>
    </ol>

    <h2>8. Allure</h2>
    <p>Allure — це інструмент для створення наглядних репортів автоматизованих тестів. Він інтегрується з TestNG, JUnit, Pytest та іншими фреймворками.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        @Attachment(value = "Screenshot", type = "image/png")<br>
        public byte[] takeScreenshot() {<br>
        &nbsp;&nbsp;return ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);<br>
        }
    </code>

    <h2>9. Сліпи</h2>
    <p>Сліпи (<code>Thread.sleep()</code>) використовуються для очікування, але їх варто уникати через затримки у тестах.</p>
    <p><strong>Приклад:</strong> <code>Thread.sleep(2000);</code></p>

    <h2>10. Логи</h2>
    <p>Логи — це записи подій у системі, які допомагають відслідковувати роботу програми.</p>
    <p><strong>Приклад у Python:</strong></p>
    <code>
        import logging<br>
        logging.basicConfig(level=logging.INFO)<br>
        logging.info("Test started")
    </code>

    <h2>11. Ретраї</h2>
    <p>Ретраї — це повторний запуск тесту при невдачі.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        @Test(retryAnalyzer = RetryAnalyzer.class)
    </code>

    <h2>12. Техніки Тест-Дизайну</h2>
        <ul>
            <li><strong>Еквівалентне розділення:</strong> Групування вхідних даних на класи</li>
            <li><strong>Аналіз граничних значень:</strong> Тестування на межах діапазонів</li>
            <li><strong>Таблиця рішень:</strong> Тестування комбінацій умов</li>
            <li><strong>Попарне тестування:</strong> Перевірка всіх можливих комбінацій парметрів</li>
        </ul>
    </div>

    <div class="topic">

    <h2>14. Що таке REST?</h2>
    <p><strong>REST</strong> (Representational State Transfer) — це архітектурний стиль для побудови веб-сервісів, який використовує HTTP для взаємодії між клієнтом і сервером. REST API забезпечує спосіб доступу до ресурсів через стандартні HTTP-методи (GET, POST, PUT, DELETE тощо).</p>

    <h2>Ключові принципи REST:</h2>
    <ul>
        <li><strong>Ресурси:</strong> Кожен ресурс ідентифікується унікальним URI (наприклад, <code>/users/1</code> для користувача з ID 1).</li>
        <li><strong>Стандартизовані методи:</strong> HTTP-методи (GET, POST, PUT, DELETE) відповідають CRUD-операціям (Create, Read, Update, Delete).</li>
        <li><strong>Безстанова взаємодія:</strong> Сервер не зберігає стану клієнта між запитами, кожен запит повинен містити всю необхідну інформацію.</li>
        <li><strong>Формати:</strong> Дані зазвичай передаються у форматі JSON або XML.</li>
    </ul>

    <h2>Відмінність між GET і POST:</h2>
    <ul>
        <li><strong>GET:</strong>
            <ul>
                <li>Призначений для отримання (читання) даних з сервера.</li>
                <li>Не змінює стан ресурсу.</li>
                <li>Дані передаються у URL (наприклад, <code>/api/v1/users?name=John</code>).</li>
                <li>Безпечний і ідемпотентний (повторні запити не змінюють результат).</li>
            </ul>
        </li>
        <li><strong>POST:</strong>
            <ul>
                <li>Призначений для створення нових ресурсів на сервері.</li>
                <li>Дані передаються у тілі запиту (body).</li>
                <li>Змінює стан сервера (додає нові записи).</li>
                <li>Не є ідемпотентним (повторний запит може створити кілька однакових ресурсів).</li>
            </ul>
        </li>
    </ul>

    <h2>Відмінність між PUT і PATCH:</h2>
    <ul>
        <li><strong>PUT:</strong>
            <ul>
                <li>Призначений для повного оновлення ресурсу.</li>
                <li>Вимагає передачі всіх полів ресурсу, навіть тих, які не змінюються.</li>
                <li>Ідемпотентний (повторний запит дає той самий результат).</li>
                <li>Наприклад, якщо ресурс <code>/users/1</code> виглядає так:</li>
            </ul>
        </li>
        <li><strong>PATCH:</strong>
            <ul>
                <li>Призначений для часткового оновлення ресурсу.</li>
                <li>Достатньо передати тільки ті поля, які змінюються.</li>
                <li>Не завжди ідемпотентний, залежить від реалізації.</li>
                </li>
            </ul>
        </li>
    </ul>


    <h2>15. Інтерфейс та Абстрактний клас</h2>

    <h2>Що таке інтерфейс?</h2>
    <p><strong>Інтерфейс</strong> — це контракт, який визначає набір методів, які клас, що реалізує цей інтерфейс, зобов'язаний реалізувати.</p>
    <ul>
        <li>В інтерфейсі <strong>немає реалізації методів</strong> (за винятком можливих дефолтних методів у Java).</li>
        <li>Інтерфейси використовуються для забезпечення багатоспадковості.</li>
        <li>Інтерфейс лише визначає <strong>що потрібно робити</strong>, а не <strong>як це потрібно робити</strong>.</li>
    </ul>

    <h2>Що таке абстрактний клас?</h2>
    <p><strong>Абстрактний клас</strong> — це клас, який не можна створити як об'єкт і який може містити як абстрактні методи (без реалізації), так і методи з реалізацією.</p>
    <ul>
        <li>Абстрактний клас використовується для задання базової поведінки, яку дочірні класи можуть розширити або перевизначити.</li>
        <li>Може містити <strong>реалізовані та нереалізовані методи</strong>.</li>
        <li>Підтримує конструкції, властиві звичайним класам (наприклад, конструктори).</li>
    </ul>

    <h2>Типи даних у Java</h2>
    <p>У Java всі дані поділяються на примітивні типи (primitive types) і об’єктні типи (reference types).</p>

        <li>Примітивні типи — це базові типи даних, які не є об’єктами. Вони забезпечують зберігання простих значень.</li>
            <li>Цілі числа (byte, short, int, long)</li>
            <li>Числа з плаваючою комою (float, double)</li>
            <li>Символи (char)</li>
            <li>Логічний тип (boolean)</li>
        <li>Об’єктні типи вказують на об’єкти в пам’яті.</li>
            <li>Зберігають посилання на об’єкти, а не значення.</li>
            <li>Приклади: String, масиви (int[]), класи, інтерфейси.</li>


    <h2>Операції в Java</h2>
    <p>Java підтримує кілька груп операцій, які дозволяють маніпулювати змінними, значеннями та об'єктами.</p>

    <h3>Групи операцій</h3>
    <table>
        <thead>
            <tr>
                <th>Група</th>
                <th>Опис</th>
                <th>Приклади</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Арифметичні</td>
                <td>Операції для математичних обчислень</td>
                <td><code>+, -, *, /, %</code></td>
            </tr>
            <tr>
                <td>Операції порівняння</td>
                <td>Порівнюють два значення</td>
                <td><code>==, !=, >, <, >=, <=</code></td>
            </tr>
            <tr>
                <td>Логічні</td>
                <td>Операції для логічних умов</td>
                <td><code>&&, ||, !</code></td>
            </tr>
            <tr>
                <td>Операції присвоєння</td>
                <td>Присвоєння значень змінним</td>
                <td><code>=, +=, -=, *=, /=, %=</code></td>
            </tr>
            <tr>
                <td>Інкремент/Декремент</td>
                <td>Збільшення або зменшення значення на одиницю</td>
                <td><code>++, --</code></td>
            </tr>
        </tbody>
    </table>

        <h2>Основні рівні тестування</h2>
    <ul>
        <li>1.	Unit Testing — тестування окремих модулів коду.</li>
        <li>2.	Integration Testing — перевірка взаємодії між модулями.</li>
        <li>3.	System Testing — тестування всієї системи як єдиного цілого.</li>
        <li>4.	Acceptance Testing — перевірка відповідності вимогам замовника.</li>
    </ul>
        <h2>Види тестування</h2>
    <ul>
        <li>1.	Функціональне — перевірка відповідності функціоналу вимогам.</li>
        <li>2.	Нефункціональне:</li>
            <li>•	Продуктивність (Performance).</li>
            <li>•	Безпека (Security).</li>
            <li>•	Юзабіліті (Usability).</li>
        <li>3.	Регресійне — перевірка, що нові зміни не порушили існуючий функціонал.</li>
        <li>4.	Смок-тестування — перевірка основних функцій перед глибшим тестуванням.</li>
        <li>5.	Саніті-тестування — перевірка частини системи після виправлення багів.</li>
    </ul>
        <h2>Основні принципи тестування</h2>
    <ul>
        <li>1.	Тестування демонструє наявність дефектів, а не їх відсутність.</li>
        <li>2.	Раннє тестування заощаджує час і ресурси.</li>
        <li>3.	Неможливо провести повне тестування.</li>
        <li>4.	Помилки групуються (80% дефектів виявляється у 20% модулів).</li>
        <li>5.	Відсутність помилок не гарантує придатності продукту.</li>
    </ul>

    <h2>Shift-Left Testing</h2>
    <p>Shift-Left Testing — це підхід, що передбачає переміщення процесів тестування на ранні етапи життєвого циклу розробки програмного забезпечення (SDLC).</p>
    <ul>
        <li><b>Ціль</b>: знайти дефекти на ранніх етапах, зменшити витрати на виправлення та покращити якість.</li>
        <li><b>Реалізація</b>: використання автоматизованих тестів (unit, integration), участь тестувальників у стадії проєктування.</li>
        <li><b>Переваги</b>: швидше виявлення помилок, зменшення ризиків, ефективність.</li>
    </ul>

    <h2>Веб-сокети</h2>
    <p>Веб-сокети — це протокол зв’язку, що забезпечує дуплексний (двосторонній) зв’язок між клієнтом і сервером через один TCP-з’єднання.</p>
    <ul>
        <li><b>Використання</b>: чати, онлайн-ігри, біржі.</li>
        <li><b>Як працюють</b>:
            <ul>
                <li>Встановлюється з’єднання через HTTP-запит.</li>
                <li>Сервер та клієнт переходять до WebSocket-протоколу.</li>
                <li>Обмін даними в реальному часі без переривання.</li>
            </ul>
        </li>
    </ul>

    <h2>Клієнт-серверна архітектура</h2>
    <p>Клієнт-серверна архітектура передбачає взаємодію між клієнтом і сервером через мережу.</p>
    <ul>
        <li><b>Клієнт</b>: відправляє запити (браузери, мобільні додатки).</li>
        <li><b>Сервер</b>: обробляє запити, виконує бізнес-логіку, повертає відповіді.</li>
        <li><b>Кеш</b>: зменшує навантаження на сервер, прискорює відповідь.</li>
        <li><b>Протоколи</b>:
            <ul>
                <li>HTTP (незахищений).</li>
                <li>HTTPS (захищений шифруванням TLS).</li>
            </ul>
        </li>
        <li><b>Шифрування HTTPS</b>: забезпечує безпеку даних через сертифікати SSL/TLS.</li>
    </ul>

    <h2>REST-запити</h2>
    <p>REST (Representational State Transfer) — архітектурний стиль, що використовує HTTP для зв’язку клієнта з сервером.</p>
    <h3>Різниця між POST і PUT:</h3>
    <ul>
        <li><b>POST</b>: створення нового ресурсу.
            <ul>
                <li>Приклад: POST /users додає нового користувача.</li>
            </ul>
        </li>
        <li><b>PUT</b>: створення або оновлення ресурсу.
            <ul>
                <li>Приклад: PUT /users/1 оновлює існуючого користувача (ID = 1).</li>
            </ul>
        </li>
    </ul>
    <h3>Query-параметри:</h3>
    <ul>
        <li>Використовуються для передачі фільтрів або умов.</li>
        <li>Приклад: GET /products?category=books&price=100.</li>
    </ul>

    <h2>Принципи тестування</h2>
    <ul>
        <li>Тестування демонструє наявність дефектів.</li>
        <li>Вичерпне тестування неможливе.</li>
        <li>Раннє тестування заощаджує ресурси.</li>
        <li>Помилки групуються (принцип Парето: 20% коду викликають 80% дефектів).</li>
        <li>Парадокс помилок (одна і та ж помилка не повинна знаходитися більше одного разу).</li>
        <li>Контекстне тестування.</li>
        <li>Відсутність помилок не гарантує придатності системи.</li>
    </ul>

    <h3>Maven:</h3>
    <ul>
        <li><b>Навіщо Maven</b>:
            <ul>
                <li>Управління залежностями (Selenium, RestAssured).</li>
                <li>Збірка та запуск тестів.</li>
                <li>Інтеграція з CI/CD.</li>
            </ul>
        </li>
    </ul>

    <h3>Merge-конфлікти:</h3>
    <ul>
        <li><b>Причини</b>:
            <ul>
                <li>Зміна одного файлу різними розробниками.</li>
                <li>Некоректний порядок виконання merge/pull.</li>
            </ul>
        </li>
        <li><b>Рішення</b>:
            <ul>
                <li>Розв’язання конфліктів у ручному режимі.</li>
                <li>Уніфікація коду за допомогою code review.</li>
            </ul>
        </li>
    </ul>
    <h2>Які протоколи передачі даних знаєте?</h2>
    <ul>
        <li>HTTP/HTTPS</li>
        <li>FTP</li>
        <li>WebSocket</li>
        <li>gRPC</li>
        <li>SMTP</li>
    </ul>

    <h2>Як можна протестувати API, що там потрібно перевіряти?</h2>
    <ul>
        <li>Коректність статус-кодів (200, 404, 500).</li>
        <li>Правильність даних у відповіді.</li>
        <li>Валідність форматів (JSON, XML).</li>
        <li>Продуктивність (затримки, обробка великого навантаження).</li>
        <li>Безпека (авторизація, вразливості).</li>
    </ul>

    <h2>Які знаєте формати передачі даних?</h2>
    <ul>
        <li>JSON</li>
        <li>XML</li>
        <li>YAML</li>
        <li>Protocol Buffers (Protobuf)</li>
        <li>CSV</li>
    </ul>

    <h2>Як відбувається шифрування?</h2>
    <p>Шифрування забезпечує перетворення даних у зашифрований формат. Приклади:</p>
    <ul>
        <li>Симетричне шифрування: AES.</li>
        <li>Асиметричне шифрування: RSA.</li>
    </ul>

    <h2>Які бувають види баз даних?</h2>
    <ul>
        <li>Реляційні (MySQL, PostgreSQL).</li>
        <li>NoSQL (MongoDB, Cassandra).</li>
        <li>Графові (Neo4j).</li>
        <li>Ключ-значення (Redis).</li>
    </ul>

    <h2>Охарактеризуйте кожен клас статус-кодів HTTP (1xx; 2xx; 3xx; 4xx; 5xx).</h2>
    <ul>
        <li><strong>1xx</strong>: Інформаційні (запит отримано).</li>
        <li><strong>2xx</strong>: Успішні (200 OK).</li>
        <li><strong>3xx</strong>: Перенаправлення (301 Moved Permanently).</li>
        <li><strong>4xx</strong>: Помилки клієнта (404 Not Found).</li>
        <li><strong>5xx</strong>: Помилки сервера (500 Internal Server Error).</li>
    </ul>

    <h2>Що таке кеш?</h2>
    <p>Кеш — це тимчасове збереження даних для швидшого доступу.</p>

    <h2>Що таке сесія?</h2>
    <p>Сесія — це період взаємодії між клієнтом і сервером збереженням стану.</p>

    <h2>Навіщо потрібні cookies?</h2>
    <p>Cookies зберігають дані користувача для персоналізації або авторизації.</p>

    <h2>Які assertions є в TestNG/JUnit?</h2>
    <p>Assertions дозволяють перевіряти очікувані результати:</p>
    <ul>
        <li><code>assertEquals(actual, expected)</code>: Перевіряє рівність.</li>
        <li><code>assertNotEquals(actual, expected)</code>: Перевіряє нерівність.</li>
        <li><code>assertTrue(condition)</code>: Перевіряє, що умова <code>true</code>.</li>
        <li><code>assertFalse(condition)</code>: Перевіряє, що умова <code>false</code>.</li>
        <li><code>assertNull(object)</code>: Перевіряє, що об'єкт <code>null</code>.</li>
        <li><code>assertNotNull(object)</code>: Перевіряє, що об'єкт не <code>null</code>.</li>
    </ul>
    <p><strong>Приклад:</strong></p>
    <code>
        Assert.assertEquals(sum(2, 2), 4, "Sum calculation failed");
    </code>

    <h2>Для чого потрібні GitHub, GitLab?</h2>
    <p>Це хостингові платформи для:</p>
    <ul>
        <li>Зберігання репозиторіїв.</li>
        <li>Спільної роботи над кодом.</li>
        <li>Інтеграції з CI/CD.</li>
    </ul>

    <h2>Що таке ООП? Назвіть його принципи з прикладами.</h2>
    <p><strong>ООП (Об’єктно-орієнтоване програмування)</strong> — це парадигма програмування, яка базується на концепції об’єктів.</p>
    <p>Принципи:</p>
    <ul>
        <li><strong>Інкапсуляція</strong>: Зберігає дані приватними, надаючи доступ через методи.
            <br><code>class Person { private String name; public String getName() { return name; } }</code>
        </li>
        <li><strong>Наслідування</strong>: Дозволяє одному класу використовувати властивості іншого.
            <br><code>class Animal { } class Dog extends Animal { }</code>
        </li>
        <li><strong>Поліморфізм</strong>: Один метод має різну реалізацію.
            <br><code>void speak(Animal a) { a.sound(); }</code>
        </li>
        <li><strong>Абстракція</strong>: Приховує складність, показуючи лише важливі деталі.
            <br><code>abstract class Shape { abstract void draw(); }</code>
        </li>
    </ul>

    <h2>Що таке інтерфейс? Що таке абстрактний клас? Чим вони відрізняються?</h2>
    <p><strong>Інтерфейс</strong>: Контракт, який клас повинен реалізувати.</p>
    <p><strong>Абстрактний клас</strong>: Клас, який може містити як абстрактні, так і конкретні методи.</p>
    <p><strong>Відмінності:</strong></p>
    <ul>
        <li>Інтерфейс може містити лише абстрактні методи (до Java 8).</li>
        <li>Абстрактний клас може мати стан (поля) і реалізовані методи.</li>
        <li>Клас може реалізувати кілька інтерфейсів, але успадковувати лише один абстрактний клас.</li>
    </ul>

    <h2>Що таке SOLID? Наведіть приклади.</h2>
    <p><strong>SOLID</strong> — це набір принципів для покращення дизайну програм:</p>
    <ul>
        <li><strong>S</strong>ingle Responsibility Principle: Один клас — одна відповідальність.</li>
        <li><strong>O</strong>pen/Closed Principle: Клас має бути відкритий для розширення, але закритий для модифікації.</li>
        <li><strong>L</strong>iskov Substitution Principle: Об’єкти підкласів можуть замінювати базові класи.</li>
        <li><strong>I</strong>nterface Segregation Principle: Краще багато дрібних інтерфейсів, ніж один великий.</li>
        <li><strong>D</strong>ependency Inversion Principle: Залежності мають бути на рівні абстракцій.</li>
    </ul>
    <p><strong>Приклад:</strong> Використання інтерфейсів для залежностей:</p>
    <code>
        interface Database { void connect(); }<br>
        class MySQL implements Database { public void connect() { /* реалізація */ } }
    </code>

    <h2>Що таке PageObject і PageFactory?</h2>
    <p><strong>PageObject</strong>: Патерн для організації тестового коду. Кожна сторінка додатка представлена окремим класом.</p>
    <p><strong>PageFactory</strong>: Бібліотека Selenium для ініціалізації веб-елементів у класі PageObject.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        public class LoginPage {<br>
        &nbsp;&nbsp;@FindBy(id = "username") WebElement username;<br>
        &nbsp;&nbsp;public void login(String user) { username.sendKeys(user); }<br>
        }
    </code>

    <h2>Яка ієрархія Collections?</h2>
    <p>Колекції в Java:</p>
    <ul>
        <li><strong>List</strong>: Збереження впорядкованих елементів (<code>ArrayList, LinkedList</code>).</li>
        <li><strong>Set</strong>: Унікальні елементи (<code>HashSet, TreeSet</code>).</li>
        <li><strong>Queue</strong>: FIFO (<code>PriorityQueue</code>).</li>
        <li><strong>Map</strong>: Пари ключ-значення (<code>HashMap, TreeMap</code>).</li>
    </ul>

    <h2>Колекції Java</h2>
    <p>Колекції Java представляють групу об'єктів. Основні інтерфейси:</p>
    <ul>
        <li><strong>List</strong>: Зберігає впорядковані елементи (ArrayList, LinkedList).</li>
        <li><strong>Set</strong>: Не допускає дублікатів (HashSet, TreeSet).</li>
        <li><strong>Map</strong>: Зберігає пари "ключ-значення" (HashMap, TreeMap).</li>
        <li><strong>Queue</strong>: Організовує елементи у чергу (PriorityQueue).</li>
    </ul>

    <h2>Ієрархія виключень у Java</h2>
    <p>Основні класи виключень:</p>
    <ul>
        <li><strong>Throwable</strong>: Базовий клас для виключень і помилок.</li>
        <li><strong>Error</strong>: Критичні помилки (OutOfMemoryError).</li>
        <li><strong>Exception</strong>: Клас для перевірених виключень (IOException, SQLException).</li>
        <li><strong>RuntimeException</strong>: Неперевірені виключення (NullPointerException).</li>
    </ul>

    <h2>Слово <code>static</code></h2>
    <p>Слово <code>static</code> використовується для позначення членів класу, які належать класу, а не об'єкту.</p>
    <p>Приклад:</p>
    <pre>
class Example {
    static int count = 0;
}
    </pre>

    </body>
</html>