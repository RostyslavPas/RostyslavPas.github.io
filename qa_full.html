<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QA</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h2 {
            color: #2c3e50;
        }
        p, ul {
            margin: 10px 0;
        }
        ul {
            padding-left: 20px;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <h1>QA</h1>

    <h2>Що таке клієнт-серверна архітектура?</h2>
    <p>Це модель взаємодії, в якій клієнт надсилає запити серверу, а сервер обробляє їх і повертає відповідь.</p>
    <p>Приклад: Браузер (клієнт) запитує сторінку у веб-сервера.</p>

    <h2>Що може виступати у ролі клієнта?</h2>
    <ul>
        <li>Веб-браузери</li>
        <li>Мобільні додатки</li>
        <li>API-клієнти (наприклад, Postman)</li>
        <li>IoT-пристрої</li>
    </ul>

    <h2>Що таке REST API, SOAP? У чому різниця?</h2>
    <p><strong>REST API</strong>: Архітектурний стиль для створення API, що використовує HTTP.</p>
    <p><strong>SOAP</strong>: Протокол для взаємодії через XML.</p>
    <p><strong>Різниця:</strong></p>
    <ul>
        <li>REST простіший у реалізації, підтримує JSON і XML, більш продуктивний.</li>
        <li>SOAP більш безпечний і стандартизований, але складніший.</li>
    </ul>

    <h2>Які протоколи передачі даних знаєте?</h2>
    <ul>
        <li>HTTP/HTTPS</li>
        <li>FTP</li>
        <li>WebSocket</li>
        <li>gRPC</li>
        <li>SMTP</li>
    </ul>

    <h2>Які методи взаємодії з API існують? У чому різниця між ними?</h2>
    <ul>
        <li><strong>GET</strong>: Отримання даних.</li>
        <li><strong>POST</strong>: Створення нового ресурсу.</li>
        <li><strong>PUT</strong>: Повне оновлення ресурсу.</li>
        <li><strong>PATCH</strong>: Часткове оновлення ресурсу.</li>
        <li><strong>DELETE</strong>: Видалення ресурсу.</li>
    </ul>

    <h2>Як можна протестувати API, що там потрібно перевіряти?</h2>
    <ul>
        <li>Коректність статус-кодів (200, 404, 500).</li>
        <li>Правильність даних у відповіді.</li>
        <li>Валідність форматів (JSON, XML).</li>
        <li>Продуктивність (затримки, обробка великого навантаження).</li>
        <li>Безпека (авторизація, вразливості).</li>
    </ul>

    <h2>Як розшифровується CRUD?</h2>
    <p><strong>CRUD</strong>: Create, Read, Update, Delete — базові операції над даними.</p>

    <h2>Чим відрізняється GET від POST?</h2>
    <ul>
        <li><strong>GET</strong>: Дані передаються в URL, ідеально для запитів без змін.</li>
        <li><strong>POST</strong>: Дані передаються у тілі запиту, використовується для зміни даних.</li>
    </ul>

    <h2>Які відмінності між XML та JSON?</h2>
    <ul>
        <li><strong>JSON</strong>: Менш об'ємний, зручніший для роботи з JavaScript.</li>
        <li><strong>XML</strong>: Формат з тегами, підтримує більше функцій (атрибути).</li>
    </ul>

    <h2>Які знаєте формати передачі даних?</h2>
    <ul>
        <li>JSON</li>
        <li>XML</li>
        <li>YAML</li>
        <li>Protocol Buffers (Protobuf)</li>
        <li>CSV</li>
    </ul>

    <h2>Як відбувається шифрування?</h2>
    <p>Шифрування забезпечує перетворення даних у зашифрований формат. Приклади:</p>
    <ul>
        <li>Симетричне шифрування: AES.</li>
        <li>Асиметричне шифрування: RSA.</li>
    </ul>

    <h2>Які бувають види баз даних?</h2>
    <ul>
        <li>Реляційні (MySQL, PostgreSQL).</li>
        <li>NoSQL (MongoDB, Cassandra).</li>
        <li>Графові (Neo4j).</li>
        <li>Ключ-значення (Redis).</li>
    </ul>

    <h2>Охарактеризуйте кожен клас статус-кодів HTTP (1xx; 2xx; 3xx; 4xx; 5xx).</h2>
    <ul>
        <li><strong>1xx</strong>: Інформаційні (запит отримано).</li>
        <li><strong>2xx</strong>: Успішні (200 OK).</li>
        <li><strong>3xx</strong>: Перенаправлення (301 Moved Permanently).</li>
        <li><strong>4xx</strong>: Помилки клієнта (404 Not Found).</li>
        <li><strong>5xx</strong>: Помилки сервера (500 Internal Server Error).</li>
    </ul>

    <h2>Які є HTTP-методи?</h2>
    <ul>
        <li>GET</li>
        <li>POST</li>
        <li>PUT</li>
        <li>DELETE</li>
        <li>PATCH</li>
        <li>OPTIONS</li>
    </ul>

    <h2>Які знаєте Web elements?</h2>
    <ul>
        <li>Текстові поля</li>
        <li>Кнопки</li>
        <li>Випадаючі списки</li>
        <li>Чекбокси</li>
        <li>Радіо-кнопки</li>
    </ul>

    <h2>Які браузери знаєте? У чому їхня відмінність?</h2>
    <p>Chrome, Firefox, Safari, Edge. Відмінності:</p>
    <ul>
        <li>Швидкість рендерингу.</li>
        <li>Рівень підтримки стандартів.</li>
        <li>Інструменти розробника.</li>
    </ul>

    <h2>Для чого потрібні інструменти розробника в браузері (Chrome DevTools)?</h2>
    <p>Для налагодження сторінок: перевірка елементів, аналіз запитів, налагодження JavaScript, перевірка стилів CSS.</p>

    <h2>Що таке кеш?</h2>
    <p>Кеш — це тимчасове збереження даних для швидшого доступу.</p>

    <h2>Що таке сесія?</h2>
    <p>Сесія — це період взаємодії між клієнтом і сервером збереженням стану.</p>

    <h2>Навіщо потрібні cookies?</h2>
    <p>Cookies зберігають дані користувача для персоналізації або авторизації.</p>

    <h2>Що таке фрейм?</h2>
    <p>Фрейм — це окрема область вікна браузера, яка завантажує контент.</p>

    <h2>Які анотації використовують у TestNG/JUnit?</h2>
    <p>Основні анотації:</p>
    <ul>
        <li><code>@Test</code>: Позначає тестовий метод.</li>
        <li><code>@BeforeSuite</code>, <code>@AfterSuite</code>: Виконуються перед або після всіх тестів у наборі.</li>
        <li><code>@BeforeTest</code>, <code>@AfterTest</code>: Виконуються перед або після тесту у файлі <code>testng.xml</code>.</li>
        <li><code>@BeforeClass</code>, <code>@AfterClass</code>: Виконуються перед або після всіх методів у класі.</li>
        <li><code>@BeforeMethod</code>, <code>@AfterMethod</code>: Виконуються перед або після кожного тестового методу.</li>
        <li><code>@DataProvider</code>: Для параметризації тестів.</li>
    </ul>
    <p><strong>Приклад:</strong></p>
    <code>
        @BeforeMethod<br>
        public void setUp() {<br>
        &nbsp;&nbsp;System.out.println("Setting up...");<br>
        }
    </code>

    <h2>Які assertions є в TestNG/JUnit?</h2>
    <p>Assertions дозволяють перевіряти очікувані результати:</p>
    <ul>
        <li><code>assertEquals(actual, expected)</code>: Перевіряє рівність.</li>
        <li><code>assertNotEquals(actual, expected)</code>: Перевіряє нерівність.</li>
        <li><code>assertTrue(condition)</code>: Перевіряє, що умова <code>true</code>.</li>
        <li><code>assertFalse(condition)</code>: Перевіряє, що умова <code>false</code>.</li>
        <li><code>assertNull(object)</code>: Перевіряє, що об'єкт <code>null</code>.</li>
        <li><code>assertNotNull(object)</code>: Перевіряє, що об'єкт не <code>null</code>.</li>
    </ul>
    <p><strong>Приклад:</strong></p>
    <code>
        Assert.assertEquals(sum(2, 2), 4, "Sum calculation failed");
    </code>

    <h2>Як виконувати тести паралельно в TestNG/JUnit?</h2>
    <p>Паралельне виконання тестів налаштовується в <code>testng.xml</code> або конфігураціях:</p>
    <code>
        &lt;suite name="Parallel Execution" parallel="methods" thread-count="4"&gt;<br>
        &nbsp;&nbsp;&lt;test name="Test1"&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;classes&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;class name="tests.MyTest"/&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;/classes&gt;<br>
        &nbsp;&nbsp;&lt;/test&gt;<br>
        &lt;/suite&gt;
    </code>

    <h2>Для чого використовують системи контролю версій?</h2>
    <p>Системи контролю версій (VCS) дозволяють:</p>
    <ul>
        <li>Зберігати історію змін у коді.</li>
        <li>Спільно працювати над проєктами.</li>
        <li>Порівнювати, об’єднувати та відновлювати зміни.</li>
    </ul>

    <h2>Що таке Git? Який принцип його роботи?</h2>
    <p><strong>Git</strong> — це розподілена система контролю версій. Принцип роботи:</p>
    <ul>
        <li>Код зберігається в локальному репозиторії.</li>
        <li>Зміни додаються через <code>commit</code>.</li>
        <li>Синхронізація з віддаленим репозиторієм через <code>push</code>/<code>pull</code>.</li>
    </ul>

    <h2>Що таке commits, branches у Git?</h2>
    <p><strong>Commit</strong>: Збереження змін у локальному репозиторії.</p>
    <p><strong>Branch</strong>: Гілка для паралельної роботи над кодом без впливу на основну.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        git commit -m "Added new feature"<br>
        git branch feature-branch
    </code>

    <h2>Для чого потрібні GitHub, GitLab?</h2>
    <p>Це хостингові платформи для:</p>
    <ul>
        <li>Зберігання репозиторіїв.</li>
        <li>Спільної роботи над кодом.</li>
        <li>Інтеграції з CI/CD.</li>
    </ul>

    <h2>Що таке CI?</h2>
    <p>CI (Continuous Integration) — практика частого об'єднання коду з репозиторієм для виявлення конфліктів.</p>

    <h2>Як автоматичне тестування інтегрується в CI?</h2>
    <p>Тести додаються як частина пайплайну CI. При кожному зміненні коду вони виконуються автоматично.</p>

    <h2>Як налаштувати Job чи Pipeline?</h2>
    <p>На прикладі Jenkins:</p>
    <ul>
        <li>Створити <strong>Job</strong>.</li>
        <li>Додати крок <code>Execute Shell</code> для запуску тестів.</li>
        <li>Налаштувати тригери (наприклад, push до репозиторію).</li>
    </ul>

    <h2>Інструменти для генерації репорту</h2>
    <ul>
        <li>Allure</li>
        <li>ExtentReports</li>
        <li>JUnit/HTML reports</li>
    </ul>

    <h2>Яку інформацію має містити звіт про виконання тестів?</h2>
    <p>Звіт повинен включати:</p>
    <ul>
        <li>Кількість виконаних тестів.</li>
        <li>Кількість успішних/провалених тестів.</li>
        <li>Час виконання.</li>
        <li>Деталі помилок (stack trace).</li>
    </ul>
    <h2>Що таке ООП? Назвіть його принципи з прикладами.</h2>
    <p><strong>ООП (Об’єктно-орієнтоване програмування)</strong> — це парадигма програмування, яка базується на концепції об’єктів.</p>
    <p>Принципи:</p>
    <ul>
        <li><strong>Інкапсуляція</strong>: Зберігає дані приватними, надаючи доступ через методи.
            <br><code>class Person { private String name; public String getName() { return name; } }</code>
        </li>
        <li><strong>Наслідування</strong>: Дозволяє одному класу використовувати властивості іншого.
            <br><code>class Animal { } class Dog extends Animal { }</code>
        </li>
        <li><strong>Поліморфізм</strong>: Один метод має різну реалізацію.
            <br><code>void speak(Animal a) { a.sound(); }</code>
        </li>
        <li><strong>Абстракція</strong>: Приховує складність, показуючи лише важливі деталі.
            <br><code>abstract class Shape { abstract void draw(); }</code>
        </li>
    </ul>

    <h2>Що таке інтерфейс? Що таке абстрактний клас? Чим вони відрізняються?</h2>
    <p><strong>Інтерфейс</strong>: Контракт, який клас повинен реалізувати.</p>
    <p><strong>Абстрактний клас</strong>: Клас, який може містити як абстрактні, так і конкретні методи.</p>
    <p><strong>Відмінності:</strong></p>
    <ul>
        <li>Інтерфейс може містити лише абстрактні методи (до Java 8).</li>
        <li>Абстрактний клас може мати стан (поля) і реалізовані методи.</li>
        <li>Клас може реалізувати кілька інтерфейсів, але успадковувати лише один абстрактний клас.</li>
    </ul>

    <h2>Що таке SOLID? Наведіть приклади.</h2>
    <p><strong>SOLID</strong> — це набір принципів для покращення дизайну програм:</p>
    <ul>
        <li><strong>S</strong>ingle Responsibility Principle: Один клас — одна відповідальність.</li>
        <li><strong>O</strong>pen/Closed Principle: Клас має бути відкритий для розширення, але закритий для модифікації.</li>
        <li><strong>L</strong>iskov Substitution Principle: Об’єкти підкласів можуть замінювати базові класи.</li>
        <li><strong>I</strong>nterface Segregation Principle: Краще багато дрібних інтерфейсів, ніж один великий.</li>
        <li><strong>D</strong>ependency Inversion Principle: Залежності мають бути на рівні абстракцій.</li>
    </ul>
    <p><strong>Приклад:</strong> Використання інтерфейсів для залежностей:</p>
    <code>
        interface Database { void connect(); }<br>
        class MySQL implements Database { public void connect() { /* реалізація */ } }
    </code>

    <h2>Що таке PageObject і PageFactory?</h2>
    <p><strong>PageObject</strong>: Патерн для організації тестового коду. Кожна сторінка додатка представлена окремим класом.</p>
    <p><strong>PageFactory</strong>: Бібліотека Selenium для ініціалізації веб-елементів у класі PageObject.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        public class LoginPage {<br>
        &nbsp;&nbsp;@FindBy(id = "username") WebElement username;<br>
        &nbsp;&nbsp;public void login(String user) { username.sendKeys(user); }<br>
        }
    </code>

    <h2>Яка ієрархія Collections?</h2>
    <p>Колекції в Java:</p>
    <ul>
        <li><strong>List</strong>: Збереження впорядкованих елементів (<code>ArrayList, LinkedList</code>).</li>
        <li><strong>Set</strong>: Унікальні елементи (<code>HashSet, TreeSet</code>).</li>
        <li><strong>Queue</strong>: FIFO (<code>PriorityQueue</code>).</li>
        <li><strong>Map</strong>: Пари ключ-значення (<code>HashMap, TreeMap</code>).</li>
    </ul>

    <h2>Різниця між final, finally і finalize?</h2>
    <p><strong>final</strong>: Ключове слово для позначення постійності.</p>
    <ul>
        <li><code>final class</code>: Клас не можна успадковувати.</li>
        <li><code>final method</code>: Метод не можна перевизначати.</li>
        <li><code>final variable</code>: Змінну не можна змінювати.</li>
    </ul>
    <p><strong>finally</strong>: Блок у try-catch для виконання коду незалежно від результату.</p>
    <p><strong>finalize</strong>: Метод, який викликається перед видаленням об’єкта.</p>
    <p><strong>Приклад:</strong></p>
    <code>
        try {<br>
        &nbsp;&nbsp;// код<br>
        } finally {<br>
        &nbsp;&nbsp;// очищення ресурсів<br>
        }
    </code>
    <h2>Які види тестування можна застосувати лише до Web?</h2>
    <ul>
        <li><strong>Кросбраузерне тестування</strong>: Перевірка коректної роботи у різних браузерах.</li>
        <li><strong>Тестування адаптивності</strong>: Перевірка роботи на різних пристроях і розширеннях екранів.</li>
        <li><strong>Тестування продуктивності</strong>: Перевірка швидкості завантаження сторінок.</li>
        <li><strong>Тестування безпеки</strong>: Виявлення уразливостей, таких як XSS або CSRF.</li>
        <li><strong>Тестування SEO</strong>: Перевірка метатегів, правильності URL і доступності для пошукових систем.</li>
    </ul>

    <h2>Для чого у вебсторінках використовують JavaScript?</h2>
    <p>JavaScript додає динамічність і інтерактивність до вебсторінок:</p>
    <ul>
        <li>Валідація форм на клієнтському боці.</li>
        <li>Анімації.</li>
        <li>Реалізація інтерактивних елементів (меню, слайдерів).</li>
        <li>Робота з DOM (додавання/видалення елементів).</li>
    </ul>

    <h2>Що таке REST?</h2>
    <p>REST (Representational State Transfer) — архітектурний стиль, який використовує HTTP для створення API, де кожен ресурс доступний за унікальним URL і може бути оброблений через стандартні HTTP-методи (GET, POST, PUT, DELETE).</p>

    <h2>Що таке AJAX?</h2>
    <p>AJAX (Asynchronous JavaScript and XML) — технологія для асинхронної взаємодії з сервером, що дозволяє оновлювати частину сторінки без повного перезавантаження.</p>

    <h2>Колекції Java</h2>
    <p>Колекції Java представляють групу об'єктів. Основні інтерфейси:</p>
    <ul>
        <li><strong>List</strong>: Зберігає впорядковані елементи (ArrayList, LinkedList).</li>
        <li><strong>Set</strong>: Не допускає дублікатів (HashSet, TreeSet).</li>
        <li><strong>Map</strong>: Зберігає пари "ключ-значення" (HashMap, TreeMap).</li>
        <li><strong>Queue</strong>: Організовує елементи у чергу (PriorityQueue).</li>
    </ul>

    <h2>Ієрархія виключень у Java</h2>
    <p>Основні класи виключень:</p>
    <ul>
        <li><strong>Throwable</strong>: Базовий клас для виключень і помилок.</li>
        <li><strong>Error</strong>: Критичні помилки (OutOfMemoryError).</li>
        <li><strong>Exception</strong>: Клас для перевірених виключень (IOException, SQLException).</li>
        <li><strong>RuntimeException</strong>: Неперевірені виключення (NullPointerException).</li>
    </ul>

    <h2>Методи <code>hashCode()</code> і <code>equals()</code>, їх реалізація</h2>
    <ul>
        <li><strong>hashCode()</strong>: Генерує числове представлення об'єкта. Використовується в хеш-таблицях.</li>
        <li><strong>equals()</strong>: Порівнює два об'єкти на логічну рівність.</li>
    </ul>
    <p>Приклад:</p>
    <pre>
class Person {
    private String name;
    private int age;

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && name.equals(person.name);
    }
}
    </pre>

    <h2>Реалізація HashMap</h2>
    <p><strong>HashMap</strong> зберігає дані у вигляді пари "ключ-значення". Використовує <code>hashCode()</code> для визначення місця зберігання даних у внутрішній хеш-таблиці.</p>

    <h2>Різниця між інтерфейсом і абстрактним класом</h2>
    <ul>
        <li><strong>Інтерфейс</strong>: Містить лише абстрактні методи (з Java 8 можливі методи з реалізацією).</li>
        <li><strong>Абстрактний клас</strong>: Може містити як абстрактні, так і реалізовані методи.</li>
    </ul>

    <h2>Методи класу <code>Object</code> у Java</h2>
    <ul>
        <li><code>toString()</code>: Повертає рядкове представлення об'єкта.</li>
        <li><code>hashCode()</code>: Генерує хеш-код об'єкта.</li>
        <li><code>equals()</code>: Порівнює два об'єкти.</li>
        <li><code>clone()</code>: Створює копію об'єкта.</li>
    </ul>

    <h2>Патерни (перерахувати з якими працював)</h2>
    <ul>
        <li><strong>Singleton</strong>: Забезпечує існування лише одного екземпляра класу.</li>
        <li><strong>Factory</strong>: Спрощує створення об'єктів.</li>
        <li><strong>Builder</strong>: Полегшує створення складних об'єктів.</li>
        <li><strong>Observer</strong>: Реалізує спостереження за станом об'єкта.</li>
    </ul>

    <h2>Слово <code>static</code></h2>
    <p>Слово <code>static</code> використовується для позначення членів класу, які належать класу, а не об'єкту.</p>
    <p>Приклад:</p>
    <pre>
class Example {
    static int count = 0;
}
    </pre>

    <h2>Внутрішні класи</h2>
    <p>Класи, які оголошені всередині іншого класу.</p>
    <ul>
        <li><strong>Static nested class</strong>: Статичний клас.</li>
        <li><strong>Inner class</strong>: Нестатичний клас.</li>
        <li><strong>Local class</strong>: Локальний клас.</li>
        <li><strong>Anonymous class</strong>: Безіменний клас.</li>
    </ul>
</body>
</html>